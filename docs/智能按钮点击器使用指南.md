# 智能按钮点击器使用指南

## 概述

`SmartButtonClicker` 是一个集成了按钮位置学习机制的通用按钮点击工具，可以自动学习和优化按钮点击的准确性。

## 核心特性

1. **智能降级策略**：YOLO → 学习器 → 缓存 → OCR → 默认坐标
2. **按设备分组学习**：每个设备独立学习，适应不同模拟器
3. **坐标合理性验证**：自动过滤不合理的坐标
4. **统计学习**：使用加权中位数算法，置信度高的坐标权重更大

## 初始化

```python
from .smart_button_clicker import SmartButtonClicker
from .model_manager import ModelManager

# 获取依赖
model_manager = ModelManager.get_instance()
detector = model_manager.get_page_detector_integrated()
ocr_pool = model_manager.get_ocr_thread_pool()

# 创建智能点击器
smart_clicker = SmartButtonClicker(adb, detector, ocr_pool)
```

## 使用方法

### 方法1：简化版（推荐）

适用于使用整合检测器的场景：

```python
success, position = await smart_clicker.click_button_simple(
    device_id=device_id,
    button_name="home_tab",  # 按钮名称（用于学习器记录）
    page_name="首页",         # 页面名称（用于YOLO检测）
    element_class_name="首页按钮",  # 元素类名（用于YOLO检测）
    valid_range=(50, 150, 850, 950),  # 合理坐标范围 (x_min, x_max, y_min, y_max)
    default_position=(90, 920),  # 默认坐标
    log_callback=lambda msg: print(msg)  # 日志回调
)

if success:
    print(f"✓ 点击成功，使用坐标: {position}")
else:
    print("❌ 点击失败")
```

### 方法2：完整版（高级）

适用于需要自定义检测逻辑的场景：

```python
# 定义YOLO检测函数
async def yolo_detect():
    button_pos = await detector.find_button_yolo(
        device_id,
        "首页",
        "首页按钮",
        conf_threshold=0.5
    )
    if button_pos:
        return (button_pos[0], button_pos[1], 0.8)  # (x, y, confidence)
    return None

# 定义OCR检测函数
async def ocr_detect():
    screenshot = await adb.screencap(device_id)
    if screenshot:
        image = Image.open(BytesIO(screenshot))
        ocr_result = await ocr_pool.recognize(image, timeout=2.0)
        if ocr_result and ocr_result.texts:
            for i, text in enumerate(ocr_result.texts):
                if "首页" in text:
                    box = ocr_result.boxes[i]
                    x = int(sum([p[0] for p in box]) / len(box))
                    y = int(sum([p[1] for p in box]) / len(box))
                    return (x, y)
    return None

# 调用智能点击
success, position = await smart_clicker.click_button(
    device_id=device_id,
    button_name="home_tab",
    valid_range=(50, 150, 850, 950),
    default_position=(90, 920),
    yolo_detector=yolo_detect,
    ocr_detector=ocr_detect,
    cached_position=cached_home_button,  # 可选的缓存坐标
    log_callback=lambda msg: print(msg)
)
```

## 常见按钮配置

### 1. 导航栏按钮

```python
# 首页按钮
await smart_clicker.click_button_simple(
    device_id=device_id,
    button_name="nav_home",
    page_name="导航栏",
    element_class_name="首页按钮",
    valid_range=(50, 150, 850, 950),
    default_position=(90, 920)
)

# 我的按钮
await smart_clicker.click_button_simple(
    device_id=device_id,
    button_name="nav_my",
    page_name="导航栏",
    element_class_name="我的按钮",
    valid_range=(400, 500, 850, 950),
    default_position=(450, 920)
)
```

### 2. 返回按钮

```python
await smart_clicker.click_button_simple(
    device_id=device_id,
    button_name="back_button",
    page_name="当前页面名称",
    element_class_name="返回按钮",
    valid_range=(10, 80, 10, 80),  # 左上角区域
    default_position=(40, 40)
)
```

### 3. 弹窗关闭按钮

```python
await smart_clicker.click_button_simple(
    device_id=device_id,
    button_name="popup_close",
    page_name="弹窗页面",
    element_class_name="关闭按钮",
    valid_range=(200, 350, 750, 850),  # 弹窗底部区域
    default_position=(270, 812)
)
```

### 4. 确认按钮

```python
await smart_clicker.click_button_simple(
    device_id=device_id,
    button_name="confirm_button",
    page_name="确认弹窗",
    element_class_name="确认按钮",
    valid_range=(200, 350, 600, 700),
    default_position=(265, 637)
)
```

## 学习器数据管理

### 数据文件位置

- 设备专属数据：`runtime_data/button_positions/device_{device_id}.json`
- 全局数据：`runtime_data/button_positions/global.json`

### 数据保留策略

- 设备专属数据：保留最近500条记录
- 全局数据：保留最近1000条记录

### 查看学习器统计信息

```python
from .button_position_learner import ButtonPositionLearner

learner = ButtonPositionLearner(device_id=device_id)
stats = learner.get_statistics("home_tab", prefer_device=True)

if stats:
    print(f"数据来源: {stats['data_source']}")  # device 或 global
    print(f"总记录数: {stats['total_count']}")
    print(f"样本数: {stats['sample_count']}")
    print(f"X坐标均值: {stats['x_mean']:.1f}")
    print(f"Y坐标均值: {stats['y_mean']:.1f}")
    print(f"X坐标标准差: {stats['x_stdev']:.1f}")
    print(f"Y坐标标准差: {stats['y_stdev']:.1f}")
```

## 最佳实践

### 1. 定义合理的坐标范围

根据按钮在屏幕上的实际位置定义合理范围：

```python
# 示例：首页签到按钮通常在屏幕右侧中下部
CHECKIN_BUTTON_VALID_RANGE = (400, 540, 500, 650)
```

### 2. 使用描述性的按钮名称

使用清晰的命名规范，便于管理和调试：

```python
# 好的命名
"home_checkin_button"  # 首页的签到按钮
"nav_home"             # 导航栏的首页按钮
"popup_close"          # 弹窗的关闭按钮

# 不好的命名
"button1"
"btn"
"click_here"
```

### 3. 记录成功点击

如果手动点击按钮（不使用智能点击器），记得记录成功坐标：

```python
from .button_position_learner import ButtonPositionLearner

learner = ButtonPositionLearner(device_id=device_id)
await adb.tap(device_id, x, y)

# 验证点击成功后记录
learner.record_success("button_name", (x, y), confidence=0.9)
```

### 4. 处理点击失败

```python
success, position = await smart_clicker.click_button_simple(...)

if not success:
    # 降级处理：使用返回键或其他方式
    await adb.press_back(device_id)
    # 或者重试
    await asyncio.sleep(1)
    success, position = await smart_clicker.click_button_simple(...)
```

## 扩展到转账功能

转账流程中的按钮也可以使用智能点击器：

```python
# 1. 余额按钮（进入钱包页）
await smart_clicker.click_button_simple(
    device_id=device_id,
    button_name="wallet_balance_button",
    page_name="个人页面",
    element_class_name="余额数字",
    valid_range=(50, 150, 180, 280),
    default_position=(91, 228)
)

# 2. 转赠按钮（进入转账页）
await smart_clicker.click_button_simple(
    device_id=device_id,
    button_name="wallet_transfer_button",
    page_name="钱包页",
    element_class_name="转赠按钮",
    valid_range=(400, 500, 50, 150),
    default_position=(456, 89)
)

# 3. 全部转账按钮
await smart_clicker.click_button_simple(
    device_id=device_id,
    button_name="transfer_all_button",
    page_name="转账页",
    element_class_name="全部转账按钮",
    valid_range=(200, 300, 250, 300),
    default_position=(250, 275)
)

# 4. ID输入框
await smart_clicker.click_button_simple(
    device_id=device_id,
    button_name="transfer_recipient_input",
    page_name="转账页",
    element_class_name="ID输入框",
    valid_range=(200, 350, 350, 420),
    default_position=(270, 381)
)

# 5. 提交按钮
await smart_clicker.click_button_simple(
    device_id=device_id,
    button_name="transfer_submit_button",
    page_name="转账页",
    element_class_name="提交按钮",
    valid_range=(200, 350, 500, 550),
    default_position=(271, 521)
)

# 6. 确认按钮（使用OCR检测）
async def detect_confirm_button_ocr():
    # OCR检测逻辑
    screenshot = await adb.screencap(device_id)
    if screenshot:
        image = Image.open(BytesIO(screenshot))
        ocr_result = await ocr_pool.recognize(image, timeout=2.0)
        if ocr_result and ocr_result.texts:
            for i, text in enumerate(ocr_result.texts):
                if "确认提交" in text or "确认" in text:
                    box = ocr_result.boxes[i]
                    x = int(sum([p[0] for p in box]) / len(box))
                    y = int(sum([p[1] for p in box]) / len(box))
                    return (x, y)
    return None

await smart_clicker.click_button(
    device_id=device_id,
    button_name="transfer_confirm_button",
    valid_range=(200, 350, 600, 650),
    default_position=(271, 615),
    ocr_detector=detect_confirm_button_ocr
)
```

### 转账流程集成示例

在 `BalanceTransfer` 类中已经完整集成了智能按钮点击器：

```python
class BalanceTransfer:
    def __init__(self, adb: ADBBridge, detector: 'PageDetectorIntegrated'):
        self.adb = adb
        self.detector = detector
        
        # 初始化智能按钮点击器
        from .smart_button_clicker import SmartButtonClicker
        from .model_manager import ModelManager
        
        model_manager = ModelManager.get_instance()
        ocr_pool = model_manager.get_ocr_thread_pool()
        self._smart_clicker = SmartButtonClicker(adb, detector, ocr_pool)
    
    async def transfer_balance(self, device_id: str, recipient_id: str, ...):
        # 转账流程中的所有按钮点击都使用智能点击器
        # 1. 点击余额按钮
        success, pos = await self._smart_clicker.click_button(...)
        
        # 2. 点击转赠按钮
        success, pos = await self._smart_clicker.click_button(...)
        
        # ... 其他按钮点击
```

### 转账按钮学习数据

转账相关按钮的学习数据会保存在：

- 设备专属：`runtime_data/button_positions/device_{device_id}.json`
- 全局数据：`runtime_data/button_positions/global.json`

按钮名称：
- `wallet_balance_button` - 余额按钮
- `wallet_transfer_button` - 转赠按钮
- `transfer_all_button` - 全部转账按钮
- `transfer_recipient_input` - ID输入框
- `transfer_submit_button` - 提交按钮
- `transfer_confirm_button` - 确认按钮

## 故障排查

### 问题1：学习器无足够数据

**现象**：日志显示"学习器无足够数据（需要至少5个样本）"

**解决方案**：
- 运行几次程序积累数据
- 检查是否正确记录了成功坐标
- 降低 `min_samples` 参数（不推荐）

### 问题2：坐标验证失败

**现象**：日志显示"坐标不合理，超出范围"

**解决方案**：
- 检查 `valid_range` 是否设置正确
- 扩大合理范围
- 检查YOLO模型是否误检测

### 问题3：所有检测方法都失败

**现象**：最终使用默认坐标

**解决方案**：
- 检查YOLO模型是否正常加载
- 检查OCR是否正常工作
- 验证默认坐标是否正确
- 检查页面是否正确显示

## 性能优化

### 1. 减少不必要的检测

```python
# 如果已经有缓存坐标，可以直接使用
if cached_position:
    await adb.tap(device_id, cached_position[0], cached_position[1])
else:
    # 只在没有缓存时使用智能点击器
    success, position = await smart_clicker.click_button_simple(...)
    if success:
        cached_position = position
```

### 2. 批量点击优化

```python
# 如果需要连续点击多个按钮，可以复用检测结果
positions = {}

for button_name in ["button1", "button2", "button3"]:
    if button_name not in positions:
        success, pos = await smart_clicker.click_button_simple(...)
        if success:
            positions[button_name] = pos
```

## 总结

智能按钮点击器通过学习机制和智能降级策略，大大提高了按钮点击的准确性和稳定性。随着运行次数的增加，学习器会积累越来越多的成功坐标数据，识别准确率会持续提升。

建议在所有需要点击按钮的地方都使用智能点击器，以获得最佳的稳定性和准确性。
