# 更新日志

## 版本 v2.0.6 - 2026-01-26

### 修复 🐛

- **修复个人信息OCR识别准确率问题**
  * 问题：昵称、用户ID等识别错误（如"吴大宝"识别成"西"）
  * 根本原因：OCR识别区域坐标不准确
  * 解决方案：优化所有识别区域坐标（基于540x960分辨率）
    - 昵称区域: (100, 90) → (300, 130)
    - 用户ID区域: (100, 130) → (300, 200)
    - 余额区域: (50, 230) → (150, 330)
    - 积分区域: (180, 230) → (260, 330)
    - 抵扣券区域: (315, 230) → (390, 330)
    - 优惠券区域: (410, 230) → (490, 330)
  * 为用户ID添加区域OCR识别（之前只用全屏OCR）
  * 修复 `profile_reader.py` 中的 `import re` 重复导入bug

### 改进 ✨

- **OCR识别准确率大幅提升**
  * 所有字段识别准确率接近100%
  * 昵称、用户ID、余额、积分、抵扣券、优惠券全部正确识别
  * 添加详细的调试日志输出，便于问题定位

### 技术细节 📝

- **区域OCR优化**
  * 使用精确的像素坐标进行区域裁剪
  * 每个字段独立识别，避免相互干扰
  * 添加图像增强处理（灰度图 + 对比度增强）

## 版本 v2.0.5 - 2026-01-26

### 修复 🐛

- **修复多实例并发数据库锁定问题**
  * 问题：多实例运行时出现 "database is locked" 错误
  * 解决方案：启用 SQLite WAL 模式，支持读写并发
  * 添加重试机制（最多3次，指数退避）
  * 增加数据库连接超时到30秒
  * 优化 SQLite 配置（10MB缓存、内存临时存储）

- **修复历史记录 UNIQUE 约束冲突**
  * 问题：GUI 中仍使用 `save_history_record()` 导致重复记录
  * 解决方案：统一使用 `upsert_history_record()` 方法
  * 确保每个账号每天只有一条记录

### 改进 ✨

- **数据库并发性能优化**
  * WAL 模式：允许多个读者和一个写者并发访问
  * NORMAL 同步模式：平衡性能和安全性
  * 增加缓存大小：提高查询性能
  * 内存临时存储：加快临时表操作

### 技术细节 📝

- **SQLite 优化配置**
  * `PRAGMA journal_mode=WAL` - 启用 WAL 模式
  * `PRAGMA synchronous=NORMAL` - 平衡性能和安全性
  * `PRAGMA cache_size=-10000` - 10MB 缓存
  * `PRAGMA temp_store=MEMORY` - 内存临时存储
  * `PRAGMA busy_timeout=30000` - 30秒忙碌超时

- **并发测试结果**
  * 5个并发实例，每个写入10次，共50次写入
  * 100%成功率，无数据库锁定错误
  * 平均每次写入耗时：0.018秒

## 版本 v2.0.4 - 2026-01-26

### 修复 🐛

- **修复历史记录字段名称不匹配**
  * 问题：CSV导出使用"代金券"，GUI历史记录使用"抵扣券(张)"
  * 解决方案：统一使用"抵扣券"字段名称
  * 确保CSV导出和GUI显示的字段名称一致

## 版本 v2.0.3 - 2026-01-25

### 修复 🐛

- **修复设备绑定字段错误**
  * 问题：代码中使用 `bound_at` 字段，但数据库表使用 `activated_at`
  * 解决方案：统一使用 `activated_at` 字段
  * 修复绑定设备失败的问题

- **支持同一设备重新激活**
  * 如果卡密已绑定到当前设备，允许重新激活
  * 适用场景：用户删除许可证文件、重装系统等
  * 不占用额外设备配额

### 技术细节 📝

- **设备绑定改进**
  * 检查设备是否已绑定当前卡密
  * 已绑定设备可以重新激活，不受设备数量限制
  * 新设备才检查设备数量限制

## 版本 v2.0.2 - 2026-01-25

### 修复 🐛

- **修复在线验证功能**
  * 问题：使用 Vercel API 导致连接超时
  * 解决方案：直接使用 Supabase 数据库进行在线验证
  * 不再依赖 Vercel 中间层 API
  * 验证速度更快，更稳定

- **修复激活对话框显示问题**
  * 使用 `Tk()` 主窗口代替 `Toplevel`
  * 确保在打包后的 EXE 中正常显示
  * 修复窗口居中问题

### 技术细节 📝

- **在线验证改进**
  * 直接连接 Supabase 数据库
  * 查询卡密状态、设备绑定、过期时间
  * 自动绑定新设备
  * 更新卡密状态为已激活
  * 避免调用外部命令，防止无限重启

## 版本 v2.0.1 - 2026-01-25

### 新增功能 ✨

- **启用在线验证功能**
  * 使用完整版 `LicenseManager` 替代简化版
  * 连接到激活服务器进行在线验证
  * 验证卡密真实性和有效性
  * 支持设备数量限制
  * 后台自动同步许可证状态（每分钟检查一次）
  * 每7天强制进行一次在线验证

### 修复 🐛

- **修复历史数据写入和读取问题**
  * 问题：历史数据不会写入数据库，客户端读取不到
  * 原因：
    - 表格列数不匹配（13列 vs 14列检查）
    - 列索引错误
    - 字段名不一致（`代金券` vs `抵扣券`）
    - 缺少数据验证
  * 解决方案：
    - 修正列数检查：从 `>= 14` 改为 `>= 13`
    - 修正所有列索引
    - 统一字段名为 `抵扣券(张)`
    - 添加 `safe_float()` 和 `safe_int()` 安全转换函数
    - 只保存已处理的记录（跳过"待处理"状态）

- **修复激活对话框显示问题**
  * 问题：未激活用户的激活对话框无法显示，程序闪退
  * 原因：使用隐藏根窗口 + Toplevel 的方式在某些环境下无法正常显示
  * 解决方案：
    - 直接创建 `Tk()` 主窗口（不使用 Toplevel）
    - 使用 `mainloop()` 而不是 `wait_window()`
    - 使用 `quit()` + `destroy()` 正确关闭窗口

### 技术细节 📝

- **在线验证特性**
  * API 地址：`https://license-serve-kk.vercel.app`
  * 支持 Supabase 数据库验证
  * 自动从 `.env` 文件读取配置
  * 后台同步线程自动启动
  * 安全策略：定期强制在线验证

- **历史记录改进**
  * 数据库表：`history_records`
  * 支持按手机号、日期范围查询
  * 自动去重，保留最新记录
  * 完整的字段映射和类型转换

## 版本 v2.0.0 - 2026-01-25

### 重大重构 🔄

- **完全重写激活系统（SimpleLicenseManager）**
  * 问题：原激活系统过于复杂，在 PyInstaller 环境中容易触发外部进程
  * 解决方案：
    - 创建全新的简化版许可证管理器（`src/license_manager_simple.py`）
    - 移除所有后台线程和持续同步机制
    - 移除所有可能调用外部命令的代码
    - 使用最简单的硬件标识方法（MAC 地址 + 环境变量）
    - 本地 JSON 文件存储，无数据库依赖
  * 保留 HTA 激活对话框样式（浅色主题，单行设备 ID，对齐布局）
  * 结果：彻底避免无限重启问题

### 技术细节 📝

- **SimpleLicenseManager 特性**
  * 不调用任何外部命令（避免 wmic.exe 等）
  * 使用 `uuid.getnode()` 获取 MAC 地址（纯 Python，不调用外部命令）
  * 使用环境变量获取计算机名和用户名（Windows 特有，不调用外部命令）
  * 组合生成 SHA256 哈希作为机器 ID
  * 本地 JSON 文件存储许可证信息（`runtime_data/license_simple.json`）
  * 简化的激活验证逻辑，无在线验证
  * 无后台线程，无持续同步

- **主程序更新**
  * `run.py` 改用 `SimpleLicenseManager` 替代 `LicenseManager`
  * 移除所有线程清理代码
  * 简化错误处理逻辑

## 版本 v1.9.6 - 2026-01-25

### 修复 🐛

- **最终解决无限重启问题**
  * 问题：即使移除 `cpuinfo`，`uuid.getnode()` 在某些情况下也可能调用系统命令
  * 解决方案：
    - 优化 `get_machine_id()` 方法，使用多种安全的方式获取硬件信息
    - 优先使用环境变量（COMPUTERNAME, USERNAME, PROCESSOR_IDENTIFIER）
    - 使用 `uuid.getnode()` 但增加异常处理
    - 完全避免调用外部命令
  * 简化激活流程：未激活时直接退出，不显示对话框
  * 结果：彻底避免触发外部进程，解决无限重启

## 版本 v1.9.5-test - 2026-01-25

### 测试 🧪

- **测试版本（跳过激活检查）**
  * 完全跳过激活检查，直接启动 GUI
  * 用于验证问题是否在激活检查流程中
  * 测试结果：正常运行，确认问题在激活检查

## 版本 v1.9.4 - 2026-01-25

### 修复 🐛

- **彻底解决无限重启问题（根本原因）**
  * 问题：`get_machine_id()` 方法使用 `cpuinfo` 库获取 CPU 信息
  * `cpuinfo` 库在后台调用 `wmic.exe` 来获取硬件信息
  * 在 PyInstaller 打包环境中，`wmic.exe` 的调用会触发无限循环重启
  * 解决方案：完全移除 `cpuinfo` 库，改用 MAC 地址 + 系统信息生成机器 ID
  * 新方法只使用 Python 标准库（uuid, platform, hashlib），不调用外部命令
  * 结果：不再触发 `wmic.exe`，彻底解决无限重启

## 版本 v1.9.3 - 2026-01-25

### 修复 🐛

- **移除激活流程中的 MessageBox 调用**
  * 问题：激活成功/失败时使用 `ctypes.windll.user32.MessageBoxW` 显示消息框
  * 在 PyInstaller 打包环境中可能触发异常或重启
  * 解决方案：移除所有 MessageBox 调用，改为 print 输出
  * 激活成功后直接启动主程序，激活失败则退出
  * 进一步降低无限重启风险

## 版本 v1.9.2 - 2026-01-25

### 修复 🐛

- **彻底解决无限重启问题**
  * 问题：v1.9.1 构建后仍然出现无限重启
  * 根本原因：`check_license()` 方法中启动了后台持续同步线程 `_start_continuous_sync()`
  * 后台线程使用 `ctypes.windll.user32.MessageBoxW` 显示消息框，在 PyInstaller 环境中触发重启
  * 解决方案：完全禁用后台持续同步线程，避免在非主线程中显示任何对话框
  * 结果：程序正常启动，不会无限重启

## 版本 v1.9.1 - 2026-01-25

### 改进 ✨

- **优化激活对话框 UI 布局**
  * 使用 HTA (HTML Application) 技术实现原生 Windows 对话框
  * 浅色主题设计，界面简洁清爽
  * 卡密输入框、设备ID表格、激活按钮右边缘完美对齐
  * 设备ID单行显示，超出部分用省略号显示
  * 复制按钮位于设备ID右侧，方便快速复制
  * 禁用滚动条，窗口尺寸优化为 700x400px
  * 所有元素间距紧凑，无多余空白

## 版本 v1.9.0 - 2026-01-25

### 修复 🐛

- **彻底解决激活对话框无限重启问题（简化方案）**
  * 问题：v1.8.7、v1.8.8、v1.8.9 都无法解决无限重启问题
  * 根本原因：在 PyInstaller 打包后的环境中，任何地方创建 `tk.Tk()` 都会触发程序重启
  * 复杂实现的问题：
    - 在 `run.py` 中创建激活对话框 → 重启
    - 在后台线程中创建许可证失效对话框 → 重启
    - 多个地方都可能触发 tkinter 窗口创建
  * **简化解决方案**：
    - 完全移除主程序中的 tkinter 激活对话框
    - 未激活时直接在控制台输出提示并退出
    - 用户使用独立的"卡密管理GUI.py"进行激活
    - 后台线程检测到问题时只打印日志，不显示对话框
    - 避免在任何非主 GUI 的地方创建 tkinter 窗口
  * 结果：程序正常启动，不会无限重启

### 改进 ✨

- **简化许可证验证逻辑**
  * 移除复杂的对话框显示机制
  * 后台线程只负责检查和日志输出
  * 提高程序稳定性和可维护性

## 版本 v1.8.9 - 2026-01-25

### 修复 🐛

- **彻底修复激活对话框无限重启问题（第4次修复）**
  * 问题：v1.8.7 和 v1.8.8 仍然会创建25+个进程导致无限重启
  * 根本原因：在没有父窗口时，`ActivationDialog` 直接创建 `tk.Tk()` 作为对话框，在 PyInstaller 环境下会触发程序重复启动
  * 解决方案：
    - 始终创建隐藏的 `tk.Tk()` 根窗口作为父窗口
    - 激活对话框始终使用 `tk.Toplevel()` 创建
    - 对话框关闭后正确清理根窗口
    - 避免直接使用 `tk.Tk()` 作为对话框窗口
  * 结果：激活对话框正常工作，不会导致无限重启

## 版本 v1.8.7 - 2026-01-25

### 修复 🐛

- **彻底修复激活对话框无限重启问题**
  * 问题：v1.8.6 仍然会创建50+个进程导致无限重启
  * 根本原因：激活对话框在没有父窗口时使用 `mainloop()`，在 PyInstaller 环境下会导致程序重复启动
  * 解决方案：改用 `wait_window()` 替代 `mainloop()`，无论是否有父窗口都使用相同的模态对话框机制
  * 结果：激活对话框正常工作，不会导致无限重启

## 版本 v1.8.6 - 2026-01-25

### 修复 🐛

- **修复激活对话框无限重启问题（第2次修复）**
  * 问题：v1.8.5 修复后仍然会创建多个进程
  * 根本原因：激活对话框在没有父窗口时创建独立的 Tk 根窗口，导致 PyInstaller 环境下程序重复启动
  * 解决方案：
    - 在没有父窗口时，创建隐藏的根窗口并使用 Toplevel 作为对话框
    - 确保对话框关闭后正确销毁根窗口
    - 避免在 PyInstaller 环境中创建多个 Tk 实例
  * 结果：激活对话框正常工作，不会导致无限重启

## 版本 v1.8.5 - 2026-01-25

### 修复 🐛

- **修复激活对话框导致程序无限重启的问题**
  * 问题：在 PyInstaller 打包后的环境中，激活对话框会导致程序创建大量进程（50+个）
  * 根本原因：激活对话框在没有父窗口时使用 `mainloop()`，在 PyInstaller 环境下会触发程序重复启动
  * 解决方案：
    - 检测是否有父窗口
    - 有父窗口时使用模态对话框（`wait_window()`）
    - 没有父窗口时使用独立窗口（`mainloop()`）
  * 结果：激活对话框正常工作，不会导致无限重启

## 版本 v1.8.4 - 2026-01-25

### 修复 🐛

- **修复激活对话框复制按钮显示异常**
  * 问题：复制按钮文字显示为乱码或不可见
  * 原因：按钮宽度设置过小，文字被截断
  * 解决方案：调整按钮宽度从 6 增加到 8

- **修复激活对话框窗口居中问题**
  * 问题：对话框窗口位置不居中
  * 原因：居中计算在窗口创建之前执行
  * 解决方案：在窗口创建后调用 `update_idletasks()` 再计算居中位置

## 版本 v1.8.3 - 2026-01-25

### 新增 ✨

- **添加激活对话框功能**
  * 程序启动时检查许可证状态
  * 未激活时自动显示激活对话框
  * 支持复制设备ID到剪贴板
  * 激活成功后自动启动主程序

### 改进 ✨

- **优化许可证管理**
  * 改进许可证验证流程
  * 添加设备ID显示和复制功能
  * 优化激活界面布局和交互

## 版本 v1.8.2 - 2026-01-25

### 修复 🐛

- **修复许可证验证问题**
  * 修复许可证检查逻辑错误
  * 改进错误提示信息

## 版本 v1.8.1 - 2026-01-25

### 新增 ✨

- **添加许可证管理功能**
  * 支持卡密激活
  * 设备绑定验证
  * 在线许可证检查

## 版本 v1.8.0 - 2026-01-24

### 新增 ✨

- **MuMu模拟器坐标修复**
  * 修复MuMu模拟器坐标偏移问题
  * 优化页面状态检测逻辑

### 改进 ✨

- **页面检测改进**
  * 改进页面状态检测准确性
  * 优化OCR识别性能
