# 整合检测器与智能等待器使用指南

## 概述

本指南介绍如何将**整合检测器**（PyTorch页面分类器 + YOLO模型）与**智能等待器**配合使用，实现高效、准确的页面导航和自动化操作。

## 核心优势

### 1. GPU加速的页面分类
- **速度**: 2.24ms（GPU）vs 10.16ms（CPU）
- **加速比**: 4.54倍
- **准确率**: 100%

### 2. 智能等待器
- **高频轮询**: 0.3秒检测一次
- **即时响应**: 检测到页面变化立即返回
- **超时保护**: 30秒超时（实际通常0.5-2秒）

### 3. 完整的元素检测
- **自动映射**: 根据页面类型自动加载YOLO模型
- **精确定位**: 检测按钮、输入框等元素
- **一键点击**: 直接点击检测到的元素

## 快速开始

### 基础使用

```python
import asyncio
from src.adb_bridge import ADBBridge
from src.page_detector_integrated import PageDetectorIntegrated
from src.page_detector import PageState
from src.performance.smart_waiter import wait_for_page

async def main():
    # 初始化
    adb = ADBBridge()
    detector = PageDetectorIntegrated(
        adb,
        classifier_model_path='page_classifier_pytorch_best.pth',  # GPU加速
        log_callback=print
    )
    
    devices = await adb.list_devices()
    device_id = devices[0]
    
    # 检测当前页面
    result = await detector.detect_page(device_id)
    print(f"当前页面: {result.state.value}")
    print(f"检测时间: {result.detection_time*1000:.2f}ms")

asyncio.run(main())
```

## 使用场景

### 场景1: 页面导航

```python
async def navigate_to_home(device_id, detector):
    """从任意页面导航到首页"""
    
    # 1. 检测当前页面
    current = await detector.detect_page(device_id, detect_elements=False)
    print(f"当前页面: {current.state.value}")
    
    # 2. 如果不在首页，按返回键
    if current.state != PageState.HOME:
        await adb.press_back(device_id)
        
        # 3. 智能等待到达首页
        result = await wait_for_page(
            device_id,
            detector,
            [PageState.HOME],
            log_callback=lambda msg: print(f"[等待] {msg}")
        )
        
        if result:
            print(f"✓ 成功到达首页 (耗时: {result.detection_time*1000:.2f}ms)")
            return True
        else:
            print("✗ 等待超时")
            return False
    
    print("✓ 已在首页")
    return True
```

### 场景2: 元素点击

```python
async def click_checkin_button(device_id, detector):
    """点击签到按钮"""
    
    # 1. 确保在首页
    current = await detector.detect_page(device_id, detect_elements=False)
    if current.state != PageState.HOME:
        print("✗ 不在首页")
        return False
    
    # 2. 点击"每日签到"按钮
    success = await detector.click_element(device_id, "每日签到按钮")
    if not success:
        print("✗ 未找到签到按钮")
        return False
    
    # 3. 智能等待进入签到页
    result = await wait_for_page(
        device_id,
        detector,
        [PageState.CHECKIN],
        log_callback=lambda msg: print(f"[等待] {msg}")
    )
    
    if result:
        print(f"✓ 成功进入签到页")
        return True
    else:
        print("✗ 等待超时")
        return False
```

### 场景3: 多页面等待

```python
async def wait_for_any_page(device_id, detector):
    """等待多个可能的页面"""
    
    # 按返回键
    await adb.press_back(device_id)
    
    # 等待可能出现的任意页面
    result = await wait_for_page(
        device_id,
        detector,
        [
            PageState.HOME,           # 首页
            PageState.PROFILE_LOGGED, # 个人页（已登录）
            PageState.PROFILE,        # 个人页（未登录）
            PageState.LOGIN,          # 登录页
        ],
        log_callback=lambda msg: print(f"[等待] {msg}")
    )
    
    if result:
        print(f"✓ 到达页面: {result.state.value}")
        return result.state
    else:
        print("✗ 等待超时")
        return None
```

### 场景4: 登录流程

```python
async def login_flow(device_id, detector, phone, password):
    """完整的登录流程"""
    
    # 1. 导航到个人页
    print("步骤1: 导航到个人页...")
    # ... 导航逻辑 ...
    
    # 2. 点击登录按钮
    print("步骤2: 点击登录按钮...")
    await detector.click_element(device_id, "请登陆按钮")
    
    # 3. 智能等待到达登录页
    print("步骤3: 等待登录页...")
    result = await wait_for_page(
        device_id,
        detector,
        [PageState.LOGIN],
        log_callback=lambda msg: print(f"  [等待] {msg}")
    )
    
    if not result:
        print("✗ 未能到达登录页")
        return False
    
    # 4. 输入账号密码
    print("步骤4: 输入账号密码...")
    # ... 输入逻辑 ...
    
    # 5. 点击登录按钮
    print("步骤5: 点击登录按钮...")
    await detector.click_element(device_id, "登陆按钮")
    
    # 6. 智能等待登录结果
    print("步骤6: 等待登录结果...")
    result = await wait_for_page(
        device_id,
        detector,
        [PageState.PROFILE_LOGGED, PageState.HOME],
        log_callback=lambda msg: print(f"  [等待] {msg}")
    )
    
    if result:
        print(f"✓ 登录成功，到达: {result.state.value}")
        return True
    else:
        print("✗ 登录超时")
        return False
```

### 场景5: 签到流程

```python
async def checkin_flow(device_id, detector):
    """完整的签到流程"""
    
    # 1. 导航到首页
    print("步骤1: 导航到首页...")
    success = await navigate_to_home(device_id, detector)
    if not success:
        return False
    
    # 2. 点击签到按钮
    print("步骤2: 点击签到按钮...")
    success = await detector.click_element(device_id, "每日签到按钮")
    if not success:
        print("✗ 未找到签到按钮")
        return False
    
    # 3. 智能等待进入签到页
    print("步骤3: 等待签到页...")
    result = await wait_for_page(
        device_id,
        detector,
        [PageState.CHECKIN],
        log_callback=lambda msg: print(f"  [等待] {msg}")
    )
    
    if not result:
        print("✗ 未能进入签到页")
        return False
    
    # 4. 点击签到按钮
    print("步骤4: 点击签到...")
    await detector.click_element(device_id, "签到按钮")
    
    # 5. 智能等待签到弹窗
    print("步骤5: 等待签到弹窗...")
    result = await wait_for_page(
        device_id,
        detector,
        [PageState.CHECKIN_POPUP],
        log_callback=lambda msg: print(f"  [等待] {msg}")
    )
    
    if result:
        print("✓ 签到成功")
        
        # 6. 关闭弹窗
        print("步骤6: 关闭弹窗...")
        await detector.click_element(device_id, "关闭按钮")
        
        # 7. 智能等待返回签到页
        await wait_for_page(
            device_id,
            detector,
            [PageState.CHECKIN],
            log_callback=lambda msg: print(f"  [等待] {msg}")
        )
        
        return True
    else:
        print("✗ 签到超时")
        return False
```

## 性能优化

### 1. 使用GPU加速

```python
# GPU加速（推荐）
detector = PageDetectorIntegrated(
    adb,
    classifier_model_path='page_classifier_pytorch_best.pth',  # 原始模型
    log_callback=print
)

# 性能: 2.24ms (GPU) vs 10.16ms (CPU)
# 加速比: 4.54x
```

### 2. 启用缓存

```python
# 第一次检测（无缓存）
result1 = await detector.detect_page(device_id, use_cache=False)

# 2秒内的重复检测会使用缓存（<1ms）
result2 = await detector.detect_page(device_id, use_cache=True)
```

### 3. 按需检测元素

```python
# 只检测页面类型（快速）
result = await detector.detect_page(device_id, detect_elements=False)

# 检测页面 + 元素（较慢，但更完整）
result = await detector.detect_page(device_id, detect_elements=True)
```

### 4. 调整智能等待器参数

```python
from src.performance.smart_waiter import SmartWaiter

waiter = SmartWaiter()

# 自定义参数
result = await waiter.wait_for_page_change(
    device_id,
    detector,
    [PageState.HOME],
    max_wait=10.0,        # 超时时间（秒）
    poll_interval=0.2,    # 轮询间隔（秒）
    stability_count=2,    # 稳定性检测次数
    log_callback=print
)
```

## 性能基准

### 页面分类（GPU加速）
- **平均时间**: 2.24ms
- **最快时间**: 1.95ms
- **检测速度**: 447 FPS

### 整合检测（页面 + 元素）
- **页面分类**: 2.24ms（GPU）
- **YOLO检测**: 50-200ms
- **总耗时**: 52-202ms

### 智能等待器
- **实际耗时**: 0.5-2秒（通常）
- **超时保护**: 30秒
- **轮询间隔**: 0.3秒

## 最佳实践

### 1. 日志输出

```python
# 使用日志回调
detector = PageDetectorIntegrated(
    adb,
    log_callback=lambda msg: print(f"[检测器] {msg}")
)

# 智能等待器日志
result = await wait_for_page(
    device_id,
    detector,
    [PageState.HOME],
    log_callback=lambda msg: print(f"[等待] {msg}")
)
```

### 2. 错误处理

```python
try:
    # 检测页面
    result = await detector.detect_page(device_id)
    
    if result.state == PageState.UNKNOWN:
        print("✗ 无法识别页面")
        return False
    
    # 点击元素
    success = await detector.click_element(device_id, "按钮名称")
    if not success:
        print("✗ 未找到元素")
        return False
    
    # 智能等待
    result = await wait_for_page(device_id, detector, [PageState.HOME])
    if not result:
        print("✗ 等待超时")
        return False
    
    return True
    
except Exception as e:
    print(f"✗ 发生错误: {e}")
    return False
```

### 3. 清理缓存

```python
# 在关键操作前清理缓存，确保检测最新状态
detector._detection_cache.clear()

# 或者禁用缓存
result = await detector.detect_page(device_id, use_cache=False)
```

### 4. 超时处理

```python
# 设置合理的超时时间
result = await wait_for_page(
    device_id,
    detector,
    [PageState.HOME],
    log_callback=print
)

if not result:
    # 超时后的处理
    print("等待超时，尝试其他方案...")
    # 重试或执行备用方案
```

## 常见问题

### Q1: GPU加速不生效？

**A**: 检查PyTorch是否正确安装CUDA支持：

```python
import torch
print(f"CUDA可用: {torch.cuda.is_available()}")
print(f"GPU名称: {torch.cuda.get_device_name(0)}")
```

### Q2: 智能等待器总是超时？

**A**: 可能的原因：
1. 期望的页面状态不正确
2. 页面加载太慢
3. 网络问题

解决方案：
- 增加超时时间
- 检查期望状态是否正确
- 添加更多可能的状态

### Q3: 元素检测失败？

**A**: 可能的原因：
1. YOLO模型未训练该元素
2. 元素名称不正确
3. 页面类型映射错误

解决方案：
- 检查 `page_yolo_mapping.json` 配置
- 确认元素名称正确
- 训练新的YOLO模型

### Q4: 检测速度慢？

**A**: 优化建议：
1. 使用GPU加速（4.54倍加速）
2. 启用缓存（2秒内重复检测）
3. 只在需要时检测元素
4. 减少轮询频率

## 测试

运行完整测试：

```bash
python test_integrated_detector_with_waiter.py
```

测试内容：
1. 基础页面检测（GPU加速）
2. 页面检测 + 元素检测
3. 智能等待器
4. 导航流程
5. 元素点击
6. 性能测试

## 总结

整合检测器与智能等待器的组合提供了：

1. **极快的页面分类** - GPU加速，2.24ms
2. **准确的元素检测** - YOLO模型，95%+准确率
3. **智能的页面等待** - 高频轮询，即时响应
4. **简洁的API** - 易于使用和集成

这是实现高效、可靠的自动化操作的最佳方案。

## 相关文档

- `整合检测器使用说明.md` - 整合检测器详细说明
- `PyTorch模型迁移总结.md` - PyTorch迁移总结
- `快速开始-PyTorch模型.md` - 快速开始指南
- `page_yolo_mapping.json` - 页面-YOLO映射配置
